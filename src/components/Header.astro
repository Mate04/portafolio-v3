---
import { getLangFromUrl, useTranslations } from "../utils/languaje.utils";
import Button from "./Button.astro";
export interface Props {
  informacion: string;
}

const { informacion } = Astro.props;
const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

---

<header class="mb-8">
  <div
    class="flex flex-col md:flex-row md:items-center md:justify-between gap-4"
  >
    <div>
      <h1 class="text-4xl font-bold text-gray-900 mb-2">Mateo Maldonado</h1>
      <p class="text-xl text-gray-600 mb-4">
        {t('title')}
      </p>
      <p class="text-gray-700 max-w-2xl">
        {informacion}
      </p>
    </div>
    <Button id="btn-download-cv" variant="default" size="lg" class="w-fit gap-2 px-6 font-bold">{t('dowload')}</Button>
  </div>
</header>

<script>
  // @ts-nocheck
  const btn = document.getElementById('btn-download-cv');
  if (btn) {
    const originalLabel = btn.textContent || 'Download';
    btn.addEventListener('click', async () => {
      const pathParts = window.location.pathname.split('/').filter(Boolean); // p.e. [] ó ['es'] ó ['es','cv']
      const locale = (pathParts[0] && pathParts[0].length === 2) ? pathParts[0] : 'es';
      try {
        btn.setAttribute('disabled', 'true');
        btn.textContent = 'Generando...';

        // Cargamos dependencias dinámicas
        const [html2CanvasMod, jsPdfMod] = await Promise.all([
          import('html2canvas'), // export default
          import('jspdf')        // puede exportar { jsPDF } o default
        ]);
        const html2canvas = (html2CanvasMod as any).default; // html2canvas siempre default
        const jsPDF = (jsPdfMod as any).jsPDF || (jsPdfMod as any).default;
        if (!html2canvas || !jsPDF) throw new Error('Dependencias PDF no cargadas');

        // Si ya estamos en la página CV usamos el body actual; si no, montamos un iframe oculto
        const isCvPage = pathParts.length >= 2 && pathParts[1] === 'cv';
        /** @type {Document|null} */
        let targetDocument = null;
  // @ts-ignore for runtime only (iframe will be HTMLIFrameElement)
  let iframe: any = null; // iframe (HTMLIFrameElement)
        if (isCvPage) {
          targetDocument = document;
        } else {
          iframe = document.createElement('iframe');
          iframe.style.position = 'fixed';
          iframe.style.left = '-9999px';
          iframe.style.top = '0';
          iframe.style.width = '1200px'; // suficiente ancho para layout
          iframe.style.height = '2000px';
          iframe.src = `/${locale}/cv`;
          document.body.appendChild(iframe);
          await new Promise((res, rej) => {
            if(!iframe) return rej(new Error('Iframe no creado'));
            iframe.onload = () => res(true);
            iframe.onerror = () => rej(new Error('Error cargando iframe CV'));
          });
          targetDocument = iframe.contentDocument;
        }

        if (!targetDocument) throw new Error('No se pudo acceder al documento CV');

        // Seleccionamos el contenedor principal del contenido
        const contentRoot = targetDocument.querySelector('.max-w-4xl') || targetDocument.body;
        if (!contentRoot) throw new Error('Contenido vacío');

        // Clonamos para poder forzar ancho controlado sin alterar la vista real
        const workArea = (isCvPage ? document.createElement('div') : targetDocument.createElement('div'));
        workArea.style.width = '800px';
  // Reducimos padding general y evitamos padding superior duplicado
  workArea.style.padding = '16px 32px 32px 32px';
        workArea.style.background = '#ffffff';
        workArea.style.color = getComputedStyle(contentRoot).color || '#000';
        workArea.style.fontFamily = getComputedStyle(contentRoot).fontFamily;
        workArea.appendChild(contentRoot.cloneNode(true));
        // Quitamos padding/margin superior del contenedor clonado (tenía p-8)
        const clonedRoot = workArea.firstElementChild;
        if (clonedRoot && clonedRoot instanceof HTMLElement) {
          clonedRoot.style.paddingTop = '0';
          clonedRoot.style.marginTop = '0';
        }
        (isCvPage ? document.body : targetDocument.body).appendChild(workArea);
        workArea.style.position = 'fixed';
        workArea.style.left = '-9999px';
        workArea.style.top = '0';

        // --- Conversión de colores OKLCH a RGB para compatibilidad con html2canvas ---
        (function fixOKLCHColors(root){
          const COLOR_PROPS = ['color','backgroundColor','borderColor','borderTopColor','borderRightColor','borderBottomColor','borderLeftColor'];
          const elements = [root, ...root.querySelectorAll('*')];
          const oklchRegex = /oklch\(([^)]+)\)/gi;

          function oklchToRgba(str){
            try {
              // Formato: oklch( L C H / A ) donde L puede venir en %, A opcional
              const partsAll = str.replace(/oklch\(|\)/g,'').split('/');
              const main = partsAll[0].trim().split(/\s+/); // L C H
              const alphaPart = partsAll[1] ? partsAll[1].trim() : null;
              if(main.length < 3) return null;
              let [L, C, H] = main;
              const A = alphaPart ? parseFloat(alphaPart) : 1;
              // Normalizamos L
              if(L.endsWith('%')) L = parseFloat(L)/100; else L = parseFloat(L); // ya 0..1
              C = parseFloat(C); // cromaticidad
              // H puede venir con deg
              if(/deg$/.test(H)) H = parseFloat(H); else H = parseFloat(H); // en grados
              const hr = (H * Math.PI)/180;
              // OKLCH -> OKLab
              const a = Math.cos(hr)*C;
              const b = Math.sin(hr)*C;
              const L_ = L;
              // OKLab -> LMS (no lineal)
              const l_ = L_ + 0.3963377774 * a + 0.2158037573 * b;
              const m_ = L_ - 0.1055613458 * a - 0.0638541728 * b;
              const s_ = L_ - 0.0894841775 * a - 1.2914855480 * b;
              const l = l_**3;
              const m = m_**3;
              const s = s_**3;
              let R =  4.0767416621*l -3.3077115913*m +0.2309699292*s;
              let G = -1.2684380046*l +2.6097574011*m -0.3413193965*s;
              let B = -0.0041960863*l -0.7034186147*m +1.7076147010*s;
              // Gamma
              function encode(v){
                return v <= 0.0031308 ? 12.92*v : 1.055*Math.pow(v,1/2.4)-0.055;
              }
              R = Math.min(1, Math.max(0, encode(R)));
              G = Math.min(1, Math.max(0, encode(G)));
              B = Math.min(1, Math.max(0, encode(B)));
              return `rgba(${Math.round(R*255)}, ${Math.round(G*255)}, ${Math.round(B*255)}, ${A})`;
            } catch(_e){
              return null;
            }
          }

          elements.forEach(el => {
            const style = getComputedStyle(el);
            COLOR_PROPS.forEach(prop => {
              const val = style[prop];
              if(!val) return;
              if(val.includes('gradient')) return; // evitamos gradientes complejos
              if(/oklch\(/i.test(val)){
                // Puede haber múltiples apariciones, intentamos reemplazar cada una.
                const newVal = val.replace(oklchRegex, (m)=>{
                  const conv = oklchToRgba(m);
                  return conv || '#000';
                });
                try { el.style[prop] = newVal; } catch(_e){}
              }
            });
          });
        })(workArea);

        // Generamos canvas
        const canvas = await html2canvas(workArea, { scale: 2, useCORS: true, backgroundColor: '#ffffff', logging: false });
        const imgData = canvas.toDataURL('image/png');

        const pdf = new jsPDF('p', 'mm', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const imgWidth = pageWidth; // ajustamos al ancho de página
        const imgHeight = (canvas.height * imgWidth) / canvas.width;

        let heightLeft = imgHeight;
        let y = 0;
        pdf.addImage(imgData, 'PNG', 0, y, imgWidth, imgHeight);
        heightLeft -= pageHeight;
        while (heightLeft > -pageHeight) { // incluye último fragmento
          y -= pageHeight; // desplazamos hacia arriba
          if (heightLeft > 0) pdf.addPage();
          if (heightLeft > 0) pdf.addImage(imgData, 'PNG', 0, y, imgWidth, imgHeight);
          heightLeft -= pageHeight;
        }

        pdf.save(`Mateo Maldonado curriculum.pdf`);

        // Limpieza
        workArea.remove();
        if (iframe) iframe.remove();
      } catch (err) {
        const e = err as any;
        const msg = (e && typeof e === 'object' && 'message' in e && e.message) ? e.message : 'Desconocido';
        console.error('Error generando PDF', err);
        alert('Error generando el PDF: ' + msg);
      } finally {
        btn.removeAttribute('disabled');
        btn.textContent = originalLabel;
      }
    });
  }
</script>
